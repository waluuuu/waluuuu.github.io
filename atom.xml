<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WaluU</title>
  
  
  <link href="https://walu.space/atom.xml" rel="self"/>
  
  <link href="https://walu.space/"/>
  <updated>2023-07-31T07:44:52.337Z</updated>
  <id>https://walu.space/</id>
  
  <author>
    <name>walu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WSL2时间错误</title>
    <link href="https://walu.space/2023/07/31/WSL2%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF/"/>
    <id>https://walu.space/2023/07/31/WSL2%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF/</id>
    <published>2023-07-31T07:43:37.000Z</published>
    <updated>2023-07-31T07:44:52.337Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://github.com/microsoft/WSL/issues/5324">https://github.com/microsoft/WSL/issues/5324</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/WSL/issues/5324&quot;&gt;https://github.com/microsoft/WSL/issues/5324&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>高峰相声记录</title>
    <link href="https://walu.space/2023/07/30/%E9%AB%98%E5%B3%B0%E7%9B%B8%E5%A3%B0%E8%AE%B0%E5%BD%95/"/>
    <id>https://walu.space/2023/07/30/%E9%AB%98%E5%B3%B0%E7%9B%B8%E5%A3%B0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-07-30T13:07:01.000Z</published>
    <updated>2023-07-31T01:20:20.331Z</updated>
    
    <content type="html"><![CDATA[<p>对高峰老师流传在网上的相声视频做个归类整合。</p><span id="more"></span><p>高峰老师几乎每周都会在小园子说相声, 说过非常多的老段子，并且每段都说过好多遍。<br>同一个老段子，过段时间再说，他可能会改动某些包袱，让相声紧贴当下。<br>德云社无论是小园子还是大剧场，都允许观众录像，因此我得以通过网络听到高老师的相声。<br>但如前面所言，高老师说过的相声太多了，搜索他几年前说过的某段相声有点费劲，不如自己把他说过的每段<br>相声都记录下来，日后找的时候也更方便。</p><p>PS: 一项浩大的工程</p><h3 id="十八愁绕口令"><a class="markdownIt-Anchor" href="#十八愁绕口令"></a> 十八愁绕口令</h3><ul><li><a href="https://www.youtube.com/watch?v=OylyuR0xGiE&amp;t=13s">十多年前高峰栾云平专场</a></li><li><a href="https://www.youtube.com/watch?v=piZsfGOZH_8&amp;t=1616s">20230507 高峰 栾云平《十八愁绕口令》</a></li></ul><h3 id="玲珑塔"><a class="markdownIt-Anchor" href="#玲珑塔"></a> 玲珑塔</h3><h3 id="报菜名"><a class="markdownIt-Anchor" href="#报菜名"></a> 报菜名</h3><h3 id="数来宝"><a class="markdownIt-Anchor" href="#数来宝"></a> 数来宝</h3><h3 id="进街数来宝"><a class="markdownIt-Anchor" href="#进街数来宝"></a> 进街数来宝</h3><h3 id="同仁堂"><a class="markdownIt-Anchor" href="#同仁堂"></a> 同仁堂</h3><h3 id="羊上树"><a class="markdownIt-Anchor" href="#羊上树"></a> 羊上树</h3><h3 id="树没叶"><a class="markdownIt-Anchor" href="#树没叶"></a> 树没叶</h3><h3 id="六口人"><a class="markdownIt-Anchor" href="#六口人"></a> 六口人</h3><h3 id="反七口"><a class="markdownIt-Anchor" href="#反七口"></a> 反七口</h3><h3 id="栓娃娃"><a class="markdownIt-Anchor" href="#栓娃娃"></a> 栓娃娃</h3><h3 id="金龟铁甲"><a class="markdownIt-Anchor" href="#金龟铁甲"></a> 金龟铁甲</h3><h3 id="夸住宅"><a class="markdownIt-Anchor" href="#夸住宅"></a> 夸住宅</h3><h3 id="红事会"><a class="markdownIt-Anchor" href="#红事会"></a> 红事会</h3><h3 id="白事会"><a class="markdownIt-Anchor" href="#白事会"></a> 白事会</h3><h3 id="大上寿"><a class="markdownIt-Anchor" href="#大上寿"></a> 大上寿</h3><h3 id="福寿全"><a class="markdownIt-Anchor" href="#福寿全"></a> 福寿全</h3><h3 id="下象棋"><a class="markdownIt-Anchor" href="#下象棋"></a> 下象棋</h3><h3 id="造厨"><a class="markdownIt-Anchor" href="#造厨"></a> 造厨</h3><h3 id="朱夫子"><a class="markdownIt-Anchor" href="#朱夫子"></a> 朱夫子</h3><h3 id="三字经"><a class="markdownIt-Anchor" href="#三字经"></a> 三字经</h3><h3 id="讲四书"><a class="markdownIt-Anchor" href="#讲四书"></a> 讲四书</h3><h3 id="揭瓦"><a class="markdownIt-Anchor" href="#揭瓦"></a> 揭瓦</h3><h3 id="自食其果"><a class="markdownIt-Anchor" href="#自食其果"></a> 自食其果</h3><h3 id="大审案"><a class="markdownIt-Anchor" href="#大审案"></a> 大审案</h3><h3 id="大保镖"><a class="markdownIt-Anchor" href="#大保镖"></a> 大保镖</h3><h3 id="文章会"><a class="markdownIt-Anchor" href="#文章会"></a> 文章会</h3><h3 id="学舞蹈"><a class="markdownIt-Anchor" href="#学舞蹈"></a> 学舞蹈</h3><h3 id="打灯谜"><a class="markdownIt-Anchor" href="#打灯谜"></a> 打灯谜</h3><h3 id="对春联"><a class="markdownIt-Anchor" href="#对春联"></a> 对春联</h3><h3 id="写对子"><a class="markdownIt-Anchor" href="#写对子"></a> 写对子</h3><h3 id="自食其果-2"><a class="markdownIt-Anchor" href="#自食其果-2"></a> 自食其果</h3><h3 id="托妻献子"><a class="markdownIt-Anchor" href="#托妻献子"></a> 托妻献子</h3><h3 id="买卖论"><a class="markdownIt-Anchor" href="#买卖论"></a> 买卖论</h3><h3 id="论梦"><a class="markdownIt-Anchor" href="#论梦"></a> 论梦</h3><h3 id="打砂锅"><a class="markdownIt-Anchor" href="#打砂锅"></a> 打砂锅</h3><h3 id="八大吉祥"><a class="markdownIt-Anchor" href="#八大吉祥"></a> 八大吉祥</h3><h3 id="五行诗"><a class="markdownIt-Anchor" href="#五行诗"></a> 五行诗</h3><h3 id="八扇屏"><a class="markdownIt-Anchor" href="#八扇屏"></a> 八扇屏</h3><h3 id="大登殿"><a class="markdownIt-Anchor" href="#大登殿"></a> 大登殿</h3><h3 id="黄鹤楼"><a class="markdownIt-Anchor" href="#黄鹤楼"></a> 黄鹤楼</h3><h3 id="洪洋洞"><a class="markdownIt-Anchor" href="#洪洋洞"></a> 洪洋洞</h3><h3 id="文昭关"><a class="markdownIt-Anchor" href="#文昭关"></a> 文昭关</h3><h3 id="捉放曹"><a class="markdownIt-Anchor" href="#捉放曹"></a> 捉放曹</h3><h3 id="批捉放"><a class="markdownIt-Anchor" href="#批捉放"></a> 批捉放</h3><h3 id="空城计"><a class="markdownIt-Anchor" href="#空城计"></a> 空城计</h3><h3 id="舞台逸事"><a class="markdownIt-Anchor" href="#舞台逸事"></a> 舞台逸事</h3><h3 id="学方言"><a class="markdownIt-Anchor" href="#学方言"></a> 学方言</h3><h3 id="学四省"><a class="markdownIt-Anchor" href="#学四省"></a> 学四省</h3><h3 id="学外语"><a class="markdownIt-Anchor" href="#学外语"></a> 学外语</h3><h3 id="学方言-2"><a class="markdownIt-Anchor" href="#学方言-2"></a> 学方言</h3><h3 id="学电台"><a class="markdownIt-Anchor" href="#学电台"></a> 学电台</h3><h3 id="学评戏"><a class="markdownIt-Anchor" href="#学评戏"></a> 学评戏</h3><h3 id="武坠子"><a class="markdownIt-Anchor" href="#武坠子"></a> 武坠子</h3><h3 id="弦子书"><a class="markdownIt-Anchor" href="#弦子书"></a> 弦子书</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;对高峰老师流传在网上的相声视频做个归类整合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="相声" scheme="https://walu.space/tags/%E7%9B%B8%E5%A3%B0/"/>
    
    <category term="娱乐" scheme="https://walu.space/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>胧月</title>
    <link href="https://walu.space/2023/07/17/%E8%83%A7%E6%9C%88/"/>
    <id>https://walu.space/2023/07/17/%E8%83%A7%E6%9C%88/</id>
    <published>2023-07-17T15:23:16.000Z</published>
    <updated>2023-07-30T14:26:16.035Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=KKU98Bn6B-I">&lt;&lt;君色々移り&gt;&gt;</a>、<a href="https://www.youtube.com/watch?v=tASF0Vj_-QE">&lt;&lt;忍びのすゝめ&gt;&gt;</a>、<a href="https://www.youtube.com/watch?v=8oBp3OLXQ8Q">&lt;&lt;朧月&gt;&gt;</a>，三首歌好像可以串起来（⊙ｏ⊙）</p><span id="more"></span>  <p>男女主是青梅竹马，后来男主当了忍者，女主进了青楼(○´･д･)ﾉ<br>好在《忍びのすゝめ》中提到男主是单恋，和《君色々移り》以及《朧月》的歌词略有冲突，不过《君色々移り》和《朧月》还是可以当成一个完整的故事来看￣へ￣</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=KKU98Bn6B-I&quot;&gt;&amp;lt;&amp;lt;君色々移り&amp;gt;&amp;gt;&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=tASF0Vj_-QE&quot;&gt;&amp;lt;&amp;lt;忍びのすゝめ&amp;gt;&amp;gt;&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=8oBp3OLXQ8Q&quot;&gt;&amp;lt;&amp;lt;朧月&amp;gt;&amp;gt;&lt;/a&gt;，三首歌好像可以串起来（⊙ｏ⊙）&lt;/p&gt;</summary>
    
    
    
    
    <category term="MafuMafu" scheme="https://walu.space/tags/MafuMafu/"/>
    
    <category term="胡言乱语" scheme="https://walu.space/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>鬼泣五一周目</title>
    <link href="https://walu.space/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/"/>
    <id>https://walu.space/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/</id>
    <published>2023-07-08T08:21:20.000Z</published>
    <updated>2023-07-08T08:37:53.192Z</updated>
    
    <content type="html"><![CDATA[<p>鬼泣五一周目达成</p><span id="more"></span><p><img src="/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/DevilMayCry5.png" alt="一周目"></p><p>鬼泣五中的招式众多，可以做出非常华丽的动作，单从连招来看，非常耐玩。但剧情有点短，两三句话就能说清楚，还没看过瘾，主线已经结束了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鬼泣五一周目达成&lt;/p&gt;</summary>
    
    
    
    <category term="娱乐" scheme="https://walu.space/categories/%E5%A8%B1%E4%B9%90/"/>
    
    
    <category term="游戏" scheme="https://walu.space/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="娱乐" scheme="https://walu.space/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树中第K小元素</title>
    <link href="https://walu.space/2023/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/"/>
    <id>https://walu.space/2023/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/</id>
    <published>2023-07-04T13:29:29.000Z</published>
    <updated>2023-07-05T15:00:31.925Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">使用中序遍历获取二叉搜索树中第K小元素</a></p><span id="more"></span>  <p><strong>中序遍历二叉搜索树，得到的序列一定是升序的</strong></p><ol><li>使用栈实现中序遍历<br>这是官方解法，思路比较简单，第K个从栈中出来的元素就是要找的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; stack;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>递归实现<br>代码逻辑我还没有想的很清楚，感觉递归也是可以做的，使用传引用的方式，把最终结果（α）当作参数传入函数。<br>使用return值记录递归次数，如果恰好是我们要找的那一次，则修改α的值，并且return -1，告诉上一层，已经找到这个数了，可以直接return。</p></li><li><p>争取明天把递归实现完成，今晚看TICU去了</p></li><li><p>递归解法(2中的思路)</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">solute</span>(root, k, count, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solute</span><span class="params">(TreeNode* root, <span class="type">int</span> k, <span class="type">int</span> &amp;count, <span class="type">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">solute</span>(root-&gt;left, k, count, res);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            count = <span class="number">-1</span>;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;res: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solute</span>(root-&gt;right, k, count, res);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            count = <span class="number">-1</span>;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/&quot;&gt;使用中序遍历获取二叉搜索树中第K小元素&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="刷题" scheme="https://walu.space/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Notion的缺陷</title>
    <link href="https://walu.space/2023/06/28/Notion%E7%9A%84%E7%BC%BA%E9%99%B7/"/>
    <id>https://walu.space/2023/06/28/Notion%E7%9A%84%E7%BC%BA%E9%99%B7/</id>
    <published>2023-06-28T09:05:14.000Z</published>
    <updated>2023-06-28T09:36:59.773Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午折腾了好几个小时的Notion ToDo List，发现很多我想要的功能都没有（；´д｀）ゞ</p><span id="more"></span><h3 id="1-模板自动填充时间"><a class="markdownIt-Anchor" href="#1-模板自动填充时间"></a> 1. 模板自动填充时间</h3><p>Notion的模板虽然可以设置自动重复，但是没法做到自动填充当前时间。背单词、刷题等任务，是我每天都会做的，所以我会让Notion模板每天都创建相同的任务，但扯淡的是，他不支持自动更新时间，你在模板上写的是哪天，重复创建每日任务的时候，时间写的还是那天，需要自己把时间改成今天</p><h3 id="2-table-view"><a class="markdownIt-Anchor" href="#2-table-view"></a> 2. Table View</h3><p>一个页面不能放两个Table View。全部的任务都放在数据库中，通过创建Table View并且设置Filter可以筛选出自己想要的内容，但Notion不支持一个页面中有多个Table View，所以，要想在一个页面同时看到两种相互冲突的任务，只能再加一个变量并且使用group进行分类</p><h3 id="3-最后编辑时间"><a class="markdownIt-Anchor" href="#3-最后编辑时间"></a> 3. 最后编辑时间</h3><p>Notion不支持获取某一列的最后编辑时间</p><h3 id="4-分组下拉填充"><a class="markdownIt-Anchor" href="#4-分组下拉填充"></a> 4. 分组&amp;下拉填充</h3><p>当使用group进行分组后，下拉填充功能又不好用了🤬</p><h3 id="5-未来优化"><a class="markdownIt-Anchor" href="#5-未来优化"></a> 5. 未来优化</h3><p>希望Notion将来可以内置Python解释器，或者微软直接Copy一个Notion(<a href="https://www.microsoft.com/en-us/microsoft-loop">微软已经在这么做了</a>)，让他的DataBase、Formula更加强大</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天下午折腾了好几个小时的Notion ToDo List，发现很多我想要的功能都没有（；´д｀）ゞ&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://walu.space/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="软件" scheme="https://walu.space/tags/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="Notion" scheme="https://walu.space/tags/Notion/"/>
    
  </entry>
  
  <entry>
    <title>再也不碰炉石传说了</title>
    <link href="https://walu.space/2023/06/24/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%A2%B0%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E4%BA%86/"/>
    <id>https://walu.space/2023/06/24/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%A2%B0%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E4%BA%86/</id>
    <published>2023-06-24T06:14:41.000Z</published>
    <updated>2023-06-24T07:00:47.261Z</updated>
    
    <content type="html"><![CDATA[<p>中午玩炉石标准模式破防了，一局都没赢┗|｀O′|┛</p><span id="more"></span><p>工作的时候，组了套40血DK<br>靠这套卡组上了白金，但死活打不到钻石<br>今天中午又想玩一下，打了四把，其中两个牧师，一个盗贼，一个法师。</p><h3 id="牧师"><a class="markdownIt-Anchor" href="#牧师"></a> 牧师</h3><ol><li>控制牧<br>偷牌好恶心，直接偷到了我的翻倍和帕奇维克，并且用偷到的帕奇维克又撕了我的希尔瓦娜斯。想着往后再坚持一下，等翻倍到了我还有一战之力，结果翻倍来的时候，我就剩14张牌了，血量也不高了，他直接拍出一个血誓，而我没抽到解牌，自己退了。</li><li>暗牧<br>暗牧前期天胡开局，而我前期没有啥解牌手段，5费用邪爆解了个场面，结果6费他直接复活了上个回合被我解掉的随从。想着下一轮有可能神抽，上了个嘲讽怪苟活一轮，结果被他用法术解掉了，直接被踢死。</li></ol><h3 id="盗贼"><a class="markdownIt-Anchor" href="#盗贼"></a> 盗贼</h3><ol><li>剑鱼贼<br>使用一堆BUFF，剑鱼刀加到了16点攻击力，4耐久，并且一堆单解，没有抗住，被砍死了。</li></ol><h3 id="法师"><a class="markdownIt-Anchor" href="#法师"></a> 法师</h3><ol><li>奥秘法<br>两个法反，两个生反，我的牌又都比较高费，前期血线被压得很低，后面直接两个4费打6的法术把我带走。</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>40血DK就是沙包，对阵快攻，前期没啥自保能力，可能解牌还没抽到，就已经被踢死了。<br>打慢速卡组，一局一二十分钟，拼谁的资源多。牧师有女武神，相当于无限法术；法师有巅峰，也相当于无限法术；大哥术可以搞个无限瑞文；奥秘贼奥秘不停，最后再来个苔丝。打上面的慢速，感觉血DK十分乏力，除非7费准时翻倍，并且8非再用蛇发女妖把翻倍拿回来，二次翻倍，否则打慢速也感觉很难打。</li><li>现在非常讨厌炉石。这一局能不能赢，运气占比很大；卡组之间有明显的强弱之分，且存在克制关系（设计师就不能把所有的卡组都设计成55开的局面吗！！！单从数学上来讲，有可能把所有的卡组都设计成55开并且还各具特色吗？）</li><li>这种输赢靠运气影响比较大的游戏，仔细一想，和赌博比较类似。赌博真的有人能够算出来自己赢的概率吗？真的有人能够根据微表情，推测出对方的点数吗？同理，炉石这种游戏，可以从一开始就把自己取胜的概率算出来吗？</li><li>以后想玩游戏，我还是老老实实打开我的steam吧，《鬼泣5》买回来后还没玩过。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;中午玩炉石标准模式破防了，一局都没赢┗|｀O′|┛&lt;/p&gt;</summary>
    
    
    
    <category term="胡言乱语" scheme="https://walu.space/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="游戏" scheme="https://walu.space/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>对称二叉树</title>
    <link href="https://walu.space/2023/06/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://walu.space/2023/06/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-06-23T15:12:44.000Z</published>
    <updated>2023-06-23T15:39:59.992Z</updated>
    
    <content type="html"><![CDATA[<p>使用迭代判断二叉树是否对称</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; LeftTree;</span><br><span class="line">            stack&lt;TreeNode*&gt; RightTree;</span><br><span class="line">            TreeNode* left = root-&gt;left;</span><br><span class="line">            TreeNode* right = root-&gt;right;</span><br><span class="line">            LeftTree.<span class="built_in">push</span>(left);</span><br><span class="line">            RightTree.<span class="built_in">push</span>(right);</span><br><span class="line">            <span class="keyword">while</span>(!LeftTree.<span class="built_in">empty</span>() &amp;&amp; !RightTree.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* tmp1 = LeftTree.<span class="built_in">top</span>();</span><br><span class="line">                TreeNode* tmp2 = RightTree.<span class="built_in">top</span>();</span><br><span class="line">                LeftTree.<span class="built_in">pop</span>();</span><br><span class="line">                RightTree.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp1 == <span class="literal">NULL</span> &amp;&amp; tmp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp1 == <span class="literal">NULL</span> || tmp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp1-&gt;val == tmp2-&gt;val)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(tmp1-&gt;left != <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        LeftTree.<span class="built_in">push</span>(tmp1-&gt;left);</span><br><span class="line">                        RightTree.<span class="built_in">push</span>(tmp2-&gt;right);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;left == <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tmp1-&gt;right != <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        LeftTree.<span class="built_in">push</span>(tmp1-&gt;right);</span><br><span class="line">                        RightTree.<span class="built_in">push</span>(tmp2-&gt;left);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;right == <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用迭代判断二叉树是否对称&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>TraverseBinaryTree</title>
    <link href="https://walu.space/2023/06/21/TraverseBinaryTree/"/>
    <id>https://walu.space/2023/06/21/TraverseBinaryTree/</id>
    <published>2023-06-21T14:54:46.000Z</published>
    <updated>2023-06-24T07:06:01.634Z</updated>
    
    <content type="html"><![CDATA[<p>使用C++实现二叉树的前中后序遍历&amp;层序遍历</p><span id="more"></span><blockquote><p>对于二叉树的前中后序遍历，在实际开发中，真的会有人用栈来实现吗？</p></blockquote><h3 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h3><ol><li>使用递归实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用栈实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* tmp = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3><ol><li>使用递归实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用栈实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    stack.<span class="built_in">push</span>(root);</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后续遍历"><a class="markdownIt-Anchor" href="#后续遍历"></a> 后续遍历</h3><ol><li>使用递归实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">postOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用栈实现<br>我傻傻的想要只用一个栈来实现后序遍历，看过题解之后，大家都是用两个栈来实现的。不过在思考过程中，想出了“中右左”遍历，再对遍历的结果前后翻转的解法。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* tmp = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a class="markdownIt-Anchor" href="#层序遍历"></a> 层序遍历</h3><blockquote><p>每一层单独使用一个vector存储</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; gquiz;</span><br><span class="line">        gquiz.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!gquiz.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            length = gquiz.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">                TreeNode* tmp = gquiz.<span class="built_in">front</span>();</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                gquiz.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    gquiz.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    gquiz.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用C++实现二叉树的前中后序遍历&amp;amp;层序遍历&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="https://walu.space/2023/06/18/KMP/"/>
    <id>https://walu.space/2023/06/18/KMP/</id>
    <published>2023-06-18T12:58:57.000Z</published>
    <updated>2023-06-18T15:15:43.122Z</updated>
    
    <content type="html"><![CDATA[<p>重学<a href="https://www.youtube.com/watch?v=3IFxpozBs2I&amp;t=826s">KMP算法</a>，列出学习过程中我比较困惑的地方，给出前缀表的python实现</p><span id="more"></span><h3 id="较难理解的部分"><a class="markdownIt-Anchor" href="#较难理解的部分"></a> 较难理解的部分</h3><blockquote><p>使用python实现前缀表的计算，加深对2的理解</p></blockquote><ol><li>为什么要计算最长公共前后缀</li><li>增加字符，最长公共前后缀无法变长时怎么处理</li></ol><h3 id="前缀表代码实现"><a class="markdownIt-Anchor" href="#前缀表代码实现"></a> 前缀表代码实现</h3><blockquote><p>感觉实现方式有点像双指针+递归</p></blockquote><ol><li>python</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_table</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="comment"># the lingest common prefix and suffix</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="comment"># prefix table &amp; init</span></span><br><span class="line">    prefix = [<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#index of the prefix table  </span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">len</span>(pattern)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;length &#123;:d&#125;, index: &#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(length, i))</span><br><span class="line">        <span class="keyword">if</span>(pattern[i] == pattern[length]):</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            prefix.append(length)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果不能和上一个最长公共前后缀组成更长的公共前后缀，使最长公共前后缀减一，</span></span><br><span class="line">        <span class="comment"># 考虑能不能和减一之后的公共前后缀组成一个更长的公共前后缀</span></span><br><span class="line">        <span class="comment"># 总结：既然和A组合之后没法生成更长的公共前后缀，那我就和试着和A的子串组合。</span></span><br><span class="line">            <span class="keyword">if</span>(length&lt;=<span class="number">0</span>):</span><br><span class="line">                prefix.append(<span class="number">0</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 关键一步，找到最长公共前后缀的最长公共前后缀</span></span><br><span class="line">                length = prefix[length-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pattern = <span class="string">&quot;ABABCABAA&quot;</span></span><br><span class="line">    prefix = prefix_table(pattern)</span><br><span class="line">    <span class="built_in">print</span>(prefix)</span><br></pre></td></tr></table></figure><ol start="2"><li>C语言（抄的黄浩杰大佬的）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prefix_table</span><span class="params">(<span class="type">char</span> pattern[], <span class="type">int</span> prefix[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern[i] == pattern[len]) &#123;</span><br><span class="line">      len++;</span><br><span class="line">      prefix[i] = len;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        len = prefix[len - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prefix[i] = len;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;重学&lt;a href=&quot;https://www.youtube.com/watch?v=3IFxpozBs2I&amp;amp;t=826s&quot;&gt;KMP算法&lt;/a&gt;，列出学习过程中我比较困惑的地方，给出前缀表的python实现&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试代码</title>
    <link href="https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <id>https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</id>
    <published>2023-06-11T03:09:31.000Z</published>
    <updated>2023-06-18T13:00:29.511Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
  <entry>
    <title>测试公式</title>
    <link href="https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E5%85%AC%E5%BC%8F/"/>
    <id>https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E5%85%AC%E5%BC%8F/</id>
    <published>2023-06-11T01:37:45.000Z</published>
    <updated>2023-06-18T14:21:16.460Z</updated>
    
    <content type="html"><![CDATA[<!-- ![mafumafu](../image/1500x500.jpg "") --><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mn>1</mn><mn>22</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- ![mafumafu](../image/1500x500.jpg &quot;&quot;) --&gt;
&lt;p class=&quot;katex-block&quot;&gt;&lt;span class=&quot;katex-display&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mat</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
  <entry>
    <title>测试图片</title>
    <link href="https://walu.space/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    <id>https://walu.space/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</id>
    <published>2023-06-10T15:37:45.000Z</published>
    <updated>2023-06-18T14:21:22.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/1500x500.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/1500x500.jpg&quot; alt&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
</feed>
