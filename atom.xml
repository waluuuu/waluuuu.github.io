<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WaluU</title>
  
  
  <link href="https://walu.space/atom.xml" rel="self"/>
  
  <link href="https://walu.space/"/>
  <updated>2023-07-30T12:32:48.461Z</updated>
  <id>https://walu.space/</id>
  
  <author>
    <name>walu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>胧月</title>
    <link href="https://walu.space/2023/07/17/%E8%83%A7%E6%9C%88/"/>
    <id>https://walu.space/2023/07/17/%E8%83%A7%E6%9C%88/</id>
    <published>2023-07-17T15:23:16.000Z</published>
    <updated>2023-07-30T12:32:48.461Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=KKU98Bn6B-I">&lt;<君色々移り>&gt;</君色々移り></a>、<a href="https://www.youtube.com/watch?v=tASF0Vj_-QE">&lt;<忍びのすゝめ>&gt;</忍びのすゝめ></a>、<a href="https://www.youtube.com/watch?v=8oBp3OLXQ8Q">&lt;<朧月>&gt;</朧月></a>，三首歌好像可以串起来（⊙ｏ⊙）<span id="more"></span> 男女主是青梅竹马，后来男主当了忍者，女主进了青楼(○´･д･)ﾉ好在《忍びのすゝめ》中提到男主是单恋，和《君色々移り》以及《朧月》的歌词略有冲突，不过《君色々移り》和《朧月》还是可以当成一个完整的故事来看￣へ￣</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=KKU98Bn6B-I&quot;&gt;&amp;lt;&lt;君色々移り&gt;&amp;gt;&lt;/君色々移り&gt;&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=tASF0Vj_-QE&quot;&gt;&amp;lt;&lt;忍びのすゝめ&gt;&amp;gt;&lt;/忍びのすゝめ&gt;&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=8oBp3OLXQ8Q&quot;&gt;&amp;lt;&lt;朧月&gt;&amp;gt;&lt;/朧月&gt;&lt;/a&gt;，三首歌好像可以串起来（⊙ｏ⊙）&lt;/p&gt;</summary>
    
    
    
    
    <category term="MafuMafu" scheme="https://walu.space/tags/MafuMafu/"/>
    
    <category term="胡言乱语" scheme="https://walu.space/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>鬼泣五一周目</title>
    <link href="https://walu.space/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/"/>
    <id>https://walu.space/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/</id>
    <published>2023-07-08T08:21:20.000Z</published>
    <updated>2023-07-08T08:37:53.192Z</updated>
    
    <content type="html"><![CDATA[<p>鬼泣五一周目达成 <span id="more"></span> <img src="/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/DevilMayCry5.png" alt="一周目"></p><p>鬼泣五中的招式众多，可以做出非常华丽的动作，单从连招来看，非常耐玩。但剧情有点短，两三句话就能说清楚，还没看过瘾，主线已经结束了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鬼泣五一周目达成&lt;/p&gt;</summary>
    
    
    
    <category term="娱乐" scheme="https://walu.space/categories/%E5%A8%B1%E4%B9%90/"/>
    
    
    <category term="游戏" scheme="https://walu.space/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="娱乐" scheme="https://walu.space/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树中第K小元素</title>
    <link href="https://walu.space/2023/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/"/>
    <id>https://walu.space/2023/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/</id>
    <published>2023-07-04T13:29:29.000Z</published>
    <updated>2023-07-05T15:00:31.925Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">使用中序遍历获取二叉搜索树中第K小元素</a><span id="more"></span></p><p><strong>中序遍历二叉搜索树，得到的序列一定是升序的</strong></p><ol type="1"><li><p>使用栈实现中序遍历<br>这是官方解法，思路比较简单，第K个从栈中出来的元素就是要找的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; stack;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>递归实现<br>代码逻辑我还没有想的很清楚，感觉递归也是可以做的，使用传引用的方式，把最终结果（α）当作参数传入函数。使用return值记录递归次数，如果恰好是我们要找的那一次，则修改α的值，并且return-1，告诉上一层，已经找到这个数了，可以直接return。</p></li><li><p>争取明天把递归实现完成，今晚看TICU去了</p></li><li><p>递归解法(2中的思路) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">solute</span>(root, k, count, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solute</span><span class="params">(TreeNode* root, <span class="type">int</span> k, <span class="type">int</span> &amp;count, <span class="type">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">solute</span>(root-&gt;left, k, count, res);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            count = <span class="number">-1</span>;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;res: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solute</span>(root-&gt;right, k, count, res);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            count = <span class="number">-1</span>;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/&quot;&gt;使用中序遍历获取二叉搜索树中第K小元素&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="刷题" scheme="https://walu.space/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Notion的缺陷</title>
    <link href="https://walu.space/2023/06/28/Notion%E7%9A%84%E7%BC%BA%E9%99%B7/"/>
    <id>https://walu.space/2023/06/28/Notion%E7%9A%84%E7%BC%BA%E9%99%B7/</id>
    <published>2023-06-28T09:05:14.000Z</published>
    <updated>2023-06-28T09:36:59.773Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午折腾了好几个小时的Notion ToDoList，发现很多我想要的功能都没有（；´д｀）ゞ <span id="more"></span></p><h3 id="模板自动填充时间">1. 模板自动填充时间</h3><p>Notion的模板虽然可以设置自动重复，但是没法做到自动填充当前时间。背单词、刷题等任务，是我每天都会做的，所以我会让Notion模板每天都创建相同的任务，但扯淡的是，他不支持自动更新时间，你在模板上写的是哪天，重复创建每日任务的时候，时间写的还是那天，需要自己把时间改成今天</p><h3 id="table-view">2. Table View</h3><p>一个页面不能放两个Table View。全部的任务都放在数据库中，通过创建TableView并且设置Filter可以筛选出自己想要的内容，但Notion不支持一个页面中有多个TableView，所以，要想在一个页面同时看到两种相互冲突的任务，只能再加一个变量并且使用group进行分类</p><h3 id="最后编辑时间">3. 最后编辑时间</h3><p>Notion不支持获取某一列的最后编辑时间<br>### 4. 分组&amp;下拉填充<br>当使用group进行分组后，下拉填充功能又不好用了🤬<br>### 5. 未来优化<br>希望Notion将来可以内置Python解释器，或者微软直接Copy一个Notion(<a href="https://www.microsoft.com/en-us/microsoft-loop">微软已经在这么做了</a>)，让他的DataBase、Formula更加强大</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天下午折腾了好几个小时的Notion ToDo
List，发现很多我想要的功能都没有（；´д｀）ゞ&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://walu.space/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="软件" scheme="https://walu.space/tags/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="Notion" scheme="https://walu.space/tags/Notion/"/>
    
  </entry>
  
  <entry>
    <title>再也不碰炉石传说了</title>
    <link href="https://walu.space/2023/06/24/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%A2%B0%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E4%BA%86/"/>
    <id>https://walu.space/2023/06/24/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%A2%B0%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E4%BA%86/</id>
    <published>2023-06-24T06:14:41.000Z</published>
    <updated>2023-06-24T07:00:47.261Z</updated>
    
    <content type="html"><![CDATA[<p>中午玩炉石标准模式破防了，一局都没赢┗|｀O′|┛ <span id="more"></span>工作的时候，组了套40血DK<br>靠这套卡组上了白金，但死活打不到钻石<br>今天中午又想玩一下，打了四把，其中两个牧师，一个盗贼，一个法师。<br>### 牧师 1. 控制牧偷牌好恶心，直接偷到了我的翻倍和帕奇维克，并且用偷到的帕奇维克又撕了我的希尔瓦娜斯。想着往后再坚持一下，等翻倍到了我还有一战之力，结果翻倍来的时候，我就剩14张牌了，血量也不高了，他直接拍出一个血誓，而我没抽到解牌，自己退了。2. 暗牧暗牧前期天胡开局，而我前期没有啥解牌手段，5费用邪爆解了个场面，结果6费他直接复活了上个回合被我解掉的随从。想着下一轮有可能神抽，上了个嘲讽怪苟活一轮，结果被他用法术解掉了，直接被踢死。</p><h3 id="盗贼">盗贼</h3><ol type="1"><li>剑鱼贼使用一堆BUFF，剑鱼刀加到了16点攻击力，4耐久，并且一堆单解，没有抗住，被砍死了。</li></ol><h3 id="法师">法师</h3><ol type="1"><li>奥秘法两个法反，两个生反，我的牌又都比较高费，前期血线被压得很低，后面直接两个4费打6的法术把我带走。</li></ol><h3 id="总结">总结</h3><ol type="1"><li>40血DK就是沙包，对阵快攻，前期没啥自保能力，可能解牌还没抽到，就已经被踢死了。打慢速卡组，一局一二十分钟，拼谁的资源多。牧师有女武神，相当于无限法术；法师有巅峰，也相当于无限法术；大哥术可以搞个无限瑞文；奥秘贼奥秘不停，最后再来个苔丝。打上面的慢速，感觉血DK十分乏力，除非7费准时翻倍，并且8非再用蛇发女妖把翻倍拿回来，二次翻倍，否则打慢速也感觉很难打。<br></li><li>现在非常讨厌炉石。这一局能不能赢，运气占比很大；卡组之间有明显的强弱之分，且存在克制关系（设计师就不能把所有的卡组都设计成55开的局面吗！！！单从数学上来讲，有可能把所有的卡组都设计成55开并且还各具特色吗？）</li><li>这种输赢靠运气影响比较大的游戏，仔细一想，和赌博比较类似。赌博真的有人能够算出来自己赢的概率吗？真的有人能够根据微表情，推测出对方的点数吗？同理，炉石这种游戏，可以从一开始就把自己取胜的概率算出来吗？</li><li>以后想玩游戏，我还是老老实实打开我的steam吧，《鬼泣5》买回来后还没玩过。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;中午玩炉石标准模式破防了，一局都没赢┗|｀O′|┛&lt;/p&gt;</summary>
    
    
    
    <category term="胡言乱语" scheme="https://walu.space/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="游戏" scheme="https://walu.space/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>对称二叉树</title>
    <link href="https://walu.space/2023/06/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://walu.space/2023/06/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-06-23T15:12:44.000Z</published>
    <updated>2023-06-23T15:39:59.992Z</updated>
    
    <content type="html"><![CDATA[<p>使用迭代判断二叉树是否对称 <span id="more"></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; LeftTree;</span><br><span class="line">            stack&lt;TreeNode*&gt; RightTree;</span><br><span class="line">            TreeNode* left = root-&gt;left;</span><br><span class="line">            TreeNode* right = root-&gt;right;</span><br><span class="line">            LeftTree.<span class="built_in">push</span>(left);</span><br><span class="line">            RightTree.<span class="built_in">push</span>(right);</span><br><span class="line">            <span class="keyword">while</span>(!LeftTree.<span class="built_in">empty</span>() &amp;&amp; !RightTree.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* tmp1 = LeftTree.<span class="built_in">top</span>();</span><br><span class="line">                TreeNode* tmp2 = RightTree.<span class="built_in">top</span>();</span><br><span class="line">                LeftTree.<span class="built_in">pop</span>();</span><br><span class="line">                RightTree.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp1 == <span class="literal">NULL</span> &amp;&amp; tmp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp1 == <span class="literal">NULL</span> || tmp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp1-&gt;val == tmp2-&gt;val)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(tmp1-&gt;left != <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        LeftTree.<span class="built_in">push</span>(tmp1-&gt;left);</span><br><span class="line">                        RightTree.<span class="built_in">push</span>(tmp2-&gt;right);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;left == <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tmp1-&gt;right != <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        LeftTree.<span class="built_in">push</span>(tmp1-&gt;right);</span><br><span class="line">                        RightTree.<span class="built_in">push</span>(tmp2-&gt;left);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;right == <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用迭代判断二叉树是否对称&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>TraverseBinaryTree</title>
    <link href="https://walu.space/2023/06/21/TraverseBinaryTree/"/>
    <id>https://walu.space/2023/06/21/TraverseBinaryTree/</id>
    <published>2023-06-21T14:54:46.000Z</published>
    <updated>2023-06-24T07:06:01.634Z</updated>
    
    <content type="html"><![CDATA[<p>使用C++实现二叉树的前中后序遍历&amp;层序遍历 <span id="more"></span></p><blockquote><p>对于二叉树的前中后序遍历，在实际开发中，真的会有人用栈来实现吗？</p></blockquote><h3 id="前序遍历">前序遍历</h3><ol type="1"><li><p>使用递归实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>使用栈实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* tmp = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="中序遍历">中序遍历</h3><ol type="1"><li><p>使用递归实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>使用栈实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    stack.<span class="built_in">push</span>(root);</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="后续遍历">后续遍历</h3><ol type="1"><li><p>使用递归实现 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">postOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>使用栈实现我傻傻的想要只用一个栈来实现后序遍历，看过题解之后，大家都是用两个栈来实现的。不过在思考过程中，想出了“中右左”遍历，再对遍历的结果前后翻转的解法。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* tmp = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="层序遍历">层序遍历</h3><blockquote><p>每一层单独使用一个vector存储</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; gquiz;</span><br><span class="line">        gquiz.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!gquiz.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            length = gquiz.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">                TreeNode* tmp = gquiz.<span class="built_in">front</span>();</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                gquiz.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    gquiz.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    gquiz.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用C++实现二叉树的前中后序遍历&amp;amp;层序遍历&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="https://walu.space/2023/06/18/KMP/"/>
    <id>https://walu.space/2023/06/18/KMP/</id>
    <published>2023-06-18T12:58:57.000Z</published>
    <updated>2023-06-18T15:15:43.122Z</updated>
    
    <content type="html"><![CDATA[<p>重学<a href="https://www.youtube.com/watch?v=3IFxpozBs2I&amp;t=826s">KMP算法</a>，列出学习过程中我比较困惑的地方，给出前缀表的python实现</p><span id="more"></span><h3 id="较难理解的部分">较难理解的部分</h3><blockquote><p>使用python实现前缀表的计算，加深对2的理解</p></blockquote><ol type="1"><li>为什么要计算最长公共前后缀</li><li>增加字符，最长公共前后缀无法变长时怎么处理</li></ol><h3 id="前缀表代码实现">前缀表代码实现</h3><blockquote><p>感觉实现方式有点像双指针+递归</p></blockquote><ol type="1"><li><p>python <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_table</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="comment"># the lingest common prefix and suffix</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="comment"># prefix table &amp; init</span></span><br><span class="line">    prefix = [<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#index of the prefix table  </span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">len</span>(pattern)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;length &#123;:d&#125;, index: &#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(length, i))</span><br><span class="line">        <span class="keyword">if</span>(pattern[i] == pattern[length]):</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            prefix.append(length)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果不能和上一个最长公共前后缀组成更长的公共前后缀，使最长公共前后缀减一，</span></span><br><span class="line">        <span class="comment"># 考虑能不能和减一之后的公共前后缀组成一个更长的公共前后缀</span></span><br><span class="line">        <span class="comment"># 总结：既然和A组合之后没法生成更长的公共前后缀，那我就和试着和A的子串组合。</span></span><br><span class="line">            <span class="keyword">if</span>(length&lt;=<span class="number">0</span>):</span><br><span class="line">                prefix.append(<span class="number">0</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 关键一步，找到最长公共前后缀的最长公共前后缀</span></span><br><span class="line">                length = prefix[length-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pattern = <span class="string">&quot;ABABCABAA&quot;</span></span><br><span class="line">    prefix = prefix_table(pattern)</span><br><span class="line">    <span class="built_in">print</span>(prefix)</span><br></pre></td></tr></table></figure></p></li><li><p>C语言（抄的黄浩杰大佬的） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prefix_table</span><span class="params">(<span class="type">char</span> pattern[], <span class="type">int</span> prefix[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern[i] == pattern[len]) &#123;</span><br><span class="line">      len++;</span><br><span class="line">      prefix[i] = len;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        len = prefix[len - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prefix[i] = len;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;重学&lt;a href=&quot;https://www.youtube.com/watch?v=3IFxpozBs2I&amp;amp;t=826s&quot;&gt;KMP算法&lt;/a&gt;，列出学习过程中我比较困惑的地方，给出前缀表的python实现&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试代码</title>
    <link href="https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <id>https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</id>
    <published>2023-06-11T03:09:31.000Z</published>
    <updated>2023-06-18T13:00:29.511Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
  <entry>
    <title>测试公式</title>
    <link href="https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E5%85%AC%E5%BC%8F/"/>
    <id>https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E5%85%AC%E5%BC%8F/</id>
    <published>2023-06-11T01:37:45.000Z</published>
    <updated>2023-06-18T14:21:16.460Z</updated>
    
    <content type="html"><![CDATA[<!-- ![mafumafu](../image/1500x500.jpg "") --><p><span class="math display">\[\frac{1}{22}\]</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- ![mafumafu](../image/1500x500.jpg &quot;&quot;) --&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[&#92;frac{1}{22}&#92;]&lt;/span&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
  <entry>
    <title>测试图片</title>
    <link href="https://walu.space/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    <id>https://walu.space/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</id>
    <published>2023-06-10T15:37:45.000Z</published>
    <updated>2023-06-18T14:21:22.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/1500x500.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/1500x500.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
</feed>
