<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WalUU</title>
  
  
  <link href="https://walu.space/atom.xml" rel="self"/>
  
  <link href="https://walu.space/"/>
  <updated>2023-09-03T07:11:13.613Z</updated>
  <id>https://walu.space/</id>
  
  <author>
    <name>walu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音乐没有标准答案</title>
    <link href="https://walu.space/2023/09/03/%E9%9F%B3%E4%B9%90%E6%B2%A1%E6%9C%89%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88/"/>
    <id>https://walu.space/2023/09/03/%E9%9F%B3%E4%B9%90%E6%B2%A1%E6%9C%89%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88/</id>
    <published>2023-09-03T03:29:34.000Z</published>
    <updated>2023-09-03T07:11:13.613Z</updated>
    
    <content type="html"><![CDATA[<p>音乐的主旨没有标准答案 <span id="more"></span></p><p>周五晚上第一次线下听了古典音乐。<br>本周五洪家楼教堂举办了音乐会，本着丰富自己人生的原则，以及受京吹的影响，报名参加了这次音乐会。之前稍微听过古典音乐，但是感觉听不懂，就没有一直听下去。为了提升本次听音乐的效果，提前听了一下几首曲子。此外，还去知乎搜了一下如何听懂古典音乐，这次搜索结果改变了我的想法，我没有必要一定要弄清楚音乐传递了啥思想，只要音乐好听就行了，作者创作音乐时，可能只是因为好玩，并没有传递啥特殊的想法。平时听的流行音乐，哪怕有歌词存在，我们可能还是无法搞清楚作者到底要传达什么思想，顶多可以分辨是悲伤还是喜悦</p><p>类比语文阅读理解，考察作者使用了什么手法以及文章结构，我完全可以接受，但考察文章表达了什么思想这种作者都无法回答的问题并设置标准答案，我认为是浪费时间，作者可能只是随便写着玩的，他也不知道故事为什么会这么发展，这个故事有什么教化意义。我想这也是我喜欢村上春树的原因，故事自然而然的发生，不用考虑其中的逻辑，只是讲述一个脑中上演的故事，一种自由的感觉。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;音乐的主旨没有标准答案&lt;/p&gt;</summary>
    
    
    
    <category term="音乐" scheme="https://walu.space/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
    <category term="娱乐" scheme="https://walu.space/tags/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="音乐" scheme="https://walu.space/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>点描の唄</title>
    <link href="https://walu.space/2023/09/01/%E7%82%B9%E6%8F%8F%E3%81%AE%E5%94%84/"/>
    <id>https://walu.space/2023/09/01/%E7%82%B9%E6%8F%8F%E3%81%AE%E5%94%84/</id>
    <published>2023-09-01T14:42:26.000Z</published>
    <updated>2023-09-03T07:15:20.040Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;&lt;点描の唄&gt;&gt;真好听</p><span id="more"></span><p>昨天晚上(8/31)看<a href="https://www.youtube.com/@Hizuki_Yui_">Yui</a>歌枠直播，第一次听到了<a href="https://www.youtube.com/watch?v=S2Va0MCUNVQ&amp;t=4385s">点描の唄</a>，觉得很好听。我非常喜欢她力量感很强的唱法，可能是直播的原因，她有时会气息不足，听不到她以最好的状态唱这首歌，有点遗憾，所以听了<a href="https://open.spotify.com/track/1sIIlVrnPhrvmTrHtzM7tV">原唱</a>，以及几个翻唱。</p><p>这两个是我比较喜欢的翻唱: <a href="https://www.youtube.com/watch?v=RNCEU6O8sx8">レヴィ・エリファ/朝日南アカネ</a>、<a href="https://www.youtube.com/watch?v=AUP3OI9Yhmc">湊あくあ/猫又おかゆ</a><br>相比于原唱的一男一女，我更喜欢两个女生的翻唱，感觉原唱的男声有点虚(⊙x⊙;)。<br>期待<a href="https://www.youtube.com/@amatsuki-official">天月</a><a href="https://www.youtube.com/@96nekoch">96猫</a>一起翻唱这首歌</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;lt;&amp;lt;点描の唄&amp;gt;&amp;gt;真好听&lt;/p&gt;</summary>
    
    
    
    <category term="娱乐" scheme="https://walu.space/categories/%E5%A8%B1%E4%B9%90/"/>
    
    
    <category term="娱乐" scheme="https://walu.space/tags/%E5%A8%B1%E4%B9%90/"/>
    
    <category term="音乐" scheme="https://walu.space/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>WSL2时间错误</title>
    <link href="https://walu.space/2023/07/31/WSL2%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF/"/>
    <id>https://walu.space/2023/07/31/WSL2%E6%97%B6%E9%97%B4%E9%94%99%E8%AF%AF/</id>
    <published>2023-07-31T07:43:37.000Z</published>
    <updated>2023-07-31T07:44:52.337Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><a href="https://github.com/microsoft/WSL/issues/5324">https://github.com/microsoft/WSL/issues/5324</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/WSL/issues/5324&quot;&gt;https://github.com/microsoft/WSL/issues/5324&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>高峰相声记录</title>
    <link href="https://walu.space/2023/07/30/%E9%AB%98%E5%B3%B0%E7%9B%B8%E5%A3%B0%E8%AE%B0%E5%BD%95/"/>
    <id>https://walu.space/2023/07/30/%E9%AB%98%E5%B3%B0%E7%9B%B8%E5%A3%B0%E8%AE%B0%E5%BD%95/</id>
    <published>2023-07-30T13:07:01.000Z</published>
    <updated>2023-07-31T01:20:20.331Z</updated>
    
    <content type="html"><![CDATA[<p>对高峰老师流传在网上的相声视频做个归类整合。</p><span id="more"></span><p>高峰老师几乎每周都会在小园子说相声, 说过非常多的老段子，并且每段都说过好多遍。<br>同一个老段子，过段时间再说，他可能会改动某些包袱，让相声紧贴当下。<br>德云社无论是小园子还是大剧场，都允许观众录像，因此我得以通过网络听到高老师的相声。<br>但如前面所言，高老师说过的相声太多了，搜索他几年前说过的某段相声有点费劲，不如自己把他说过的每段<br>相声都记录下来，日后找的时候也更方便。</p><p>PS: 一项浩大的工程</p><h3 id="十八愁绕口令"><a class="markdownIt-Anchor" href="#十八愁绕口令"></a> 十八愁绕口令</h3><ul><li><a href="https://www.youtube.com/watch?v=OylyuR0xGiE&amp;t=13s">十多年前高峰栾云平专场</a></li><li><a href="https://www.youtube.com/watch?v=piZsfGOZH_8&amp;t=1616s">20230507 高峰 栾云平《十八愁绕口令》</a></li></ul><h3 id="玲珑塔"><a class="markdownIt-Anchor" href="#玲珑塔"></a> 玲珑塔</h3><h3 id="报菜名"><a class="markdownIt-Anchor" href="#报菜名"></a> 报菜名</h3><h3 id="数来宝"><a class="markdownIt-Anchor" href="#数来宝"></a> 数来宝</h3><h3 id="进街数来宝"><a class="markdownIt-Anchor" href="#进街数来宝"></a> 进街数来宝</h3><h3 id="同仁堂"><a class="markdownIt-Anchor" href="#同仁堂"></a> 同仁堂</h3><h3 id="羊上树"><a class="markdownIt-Anchor" href="#羊上树"></a> 羊上树</h3><h3 id="树没叶"><a class="markdownIt-Anchor" href="#树没叶"></a> 树没叶</h3><h3 id="六口人"><a class="markdownIt-Anchor" href="#六口人"></a> 六口人</h3><h3 id="反七口"><a class="markdownIt-Anchor" href="#反七口"></a> 反七口</h3><h3 id="栓娃娃"><a class="markdownIt-Anchor" href="#栓娃娃"></a> 栓娃娃</h3><h3 id="金龟铁甲"><a class="markdownIt-Anchor" href="#金龟铁甲"></a> 金龟铁甲</h3><h3 id="夸住宅"><a class="markdownIt-Anchor" href="#夸住宅"></a> 夸住宅</h3><h3 id="红事会"><a class="markdownIt-Anchor" href="#红事会"></a> 红事会</h3><h3 id="白事会"><a class="markdownIt-Anchor" href="#白事会"></a> 白事会</h3><h3 id="大上寿"><a class="markdownIt-Anchor" href="#大上寿"></a> 大上寿</h3><h3 id="福寿全"><a class="markdownIt-Anchor" href="#福寿全"></a> 福寿全</h3><h3 id="下象棋"><a class="markdownIt-Anchor" href="#下象棋"></a> 下象棋</h3><h3 id="造厨"><a class="markdownIt-Anchor" href="#造厨"></a> 造厨</h3><h3 id="朱夫子"><a class="markdownIt-Anchor" href="#朱夫子"></a> 朱夫子</h3><h3 id="三字经"><a class="markdownIt-Anchor" href="#三字经"></a> 三字经</h3><h3 id="讲四书"><a class="markdownIt-Anchor" href="#讲四书"></a> 讲四书</h3><h3 id="揭瓦"><a class="markdownIt-Anchor" href="#揭瓦"></a> 揭瓦</h3><h3 id="自食其果"><a class="markdownIt-Anchor" href="#自食其果"></a> 自食其果</h3><h3 id="大审案"><a class="markdownIt-Anchor" href="#大审案"></a> 大审案</h3><h3 id="大保镖"><a class="markdownIt-Anchor" href="#大保镖"></a> 大保镖</h3><h3 id="文章会"><a class="markdownIt-Anchor" href="#文章会"></a> 文章会</h3><h3 id="学舞蹈"><a class="markdownIt-Anchor" href="#学舞蹈"></a> 学舞蹈</h3><h3 id="打灯谜"><a class="markdownIt-Anchor" href="#打灯谜"></a> 打灯谜</h3><h3 id="对春联"><a class="markdownIt-Anchor" href="#对春联"></a> 对春联</h3><h3 id="写对子"><a class="markdownIt-Anchor" href="#写对子"></a> 写对子</h3><h3 id="自食其果-2"><a class="markdownIt-Anchor" href="#自食其果-2"></a> 自食其果</h3><h3 id="托妻献子"><a class="markdownIt-Anchor" href="#托妻献子"></a> 托妻献子</h3><h3 id="买卖论"><a class="markdownIt-Anchor" href="#买卖论"></a> 买卖论</h3><h3 id="论梦"><a class="markdownIt-Anchor" href="#论梦"></a> 论梦</h3><h3 id="打砂锅"><a class="markdownIt-Anchor" href="#打砂锅"></a> 打砂锅</h3><h3 id="八大吉祥"><a class="markdownIt-Anchor" href="#八大吉祥"></a> 八大吉祥</h3><h3 id="五行诗"><a class="markdownIt-Anchor" href="#五行诗"></a> 五行诗</h3><h3 id="八扇屏"><a class="markdownIt-Anchor" href="#八扇屏"></a> 八扇屏</h3><h3 id="大登殿"><a class="markdownIt-Anchor" href="#大登殿"></a> 大登殿</h3><h3 id="黄鹤楼"><a class="markdownIt-Anchor" href="#黄鹤楼"></a> 黄鹤楼</h3><h3 id="洪洋洞"><a class="markdownIt-Anchor" href="#洪洋洞"></a> 洪洋洞</h3><h3 id="文昭关"><a class="markdownIt-Anchor" href="#文昭关"></a> 文昭关</h3><h3 id="捉放曹"><a class="markdownIt-Anchor" href="#捉放曹"></a> 捉放曹</h3><h3 id="批捉放"><a class="markdownIt-Anchor" href="#批捉放"></a> 批捉放</h3><h3 id="空城计"><a class="markdownIt-Anchor" href="#空城计"></a> 空城计</h3><h3 id="舞台逸事"><a class="markdownIt-Anchor" href="#舞台逸事"></a> 舞台逸事</h3><h3 id="学方言"><a class="markdownIt-Anchor" href="#学方言"></a> 学方言</h3><h3 id="学四省"><a class="markdownIt-Anchor" href="#学四省"></a> 学四省</h3><h3 id="学外语"><a class="markdownIt-Anchor" href="#学外语"></a> 学外语</h3><h3 id="学方言-2"><a class="markdownIt-Anchor" href="#学方言-2"></a> 学方言</h3><h3 id="学电台"><a class="markdownIt-Anchor" href="#学电台"></a> 学电台</h3><h3 id="学评戏"><a class="markdownIt-Anchor" href="#学评戏"></a> 学评戏</h3><h3 id="武坠子"><a class="markdownIt-Anchor" href="#武坠子"></a> 武坠子</h3><h3 id="弦子书"><a class="markdownIt-Anchor" href="#弦子书"></a> 弦子书</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;对高峰老师流传在网上的相声视频做个归类整合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="相声" scheme="https://walu.space/tags/%E7%9B%B8%E5%A3%B0/"/>
    
    <category term="娱乐" scheme="https://walu.space/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>胧月</title>
    <link href="https://walu.space/2023/07/17/%E8%83%A7%E6%9C%88/"/>
    <id>https://walu.space/2023/07/17/%E8%83%A7%E6%9C%88/</id>
    <published>2023-07-17T15:23:16.000Z</published>
    <updated>2023-07-30T14:26:16.035Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=KKU98Bn6B-I">&lt;&lt;君色々移り&gt;&gt;</a>、<a href="https://www.youtube.com/watch?v=tASF0Vj_-QE">&lt;&lt;忍びのすゝめ&gt;&gt;</a>、<a href="https://www.youtube.com/watch?v=8oBp3OLXQ8Q">&lt;&lt;朧月&gt;&gt;</a>，三首歌好像可以串起来（⊙ｏ⊙）</p><span id="more"></span>  <p>男女主是青梅竹马，后来男主当了忍者，女主进了青楼(○´･д･)ﾉ<br>好在《忍びのすゝめ》中提到男主是单恋，和《君色々移り》以及《朧月》的歌词略有冲突，不过《君色々移り》和《朧月》还是可以当成一个完整的故事来看￣へ￣</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=KKU98Bn6B-I&quot;&gt;&amp;lt;&amp;lt;君色々移り&amp;gt;&amp;gt;&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=tASF0Vj_-QE&quot;&gt;&amp;lt;&amp;lt;忍びのすゝめ&amp;gt;&amp;gt;&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=8oBp3OLXQ8Q&quot;&gt;&amp;lt;&amp;lt;朧月&amp;gt;&amp;gt;&lt;/a&gt;，三首歌好像可以串起来（⊙ｏ⊙）&lt;/p&gt;</summary>
    
    
    
    
    <category term="MafuMafu" scheme="https://walu.space/tags/MafuMafu/"/>
    
    <category term="胡言乱语" scheme="https://walu.space/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>鬼泣五一周目</title>
    <link href="https://walu.space/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/"/>
    <id>https://walu.space/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/</id>
    <published>2023-07-08T08:21:20.000Z</published>
    <updated>2023-07-08T08:37:53.192Z</updated>
    
    <content type="html"><![CDATA[<p>鬼泣五一周目达成</p><span id="more"></span><p><img src="/2023/07/08/%E9%AC%BC%E6%B3%A3%E4%BA%94%E4%B8%80%E5%91%A8%E7%9B%AE/DevilMayCry5.png" alt="一周目"></p><p>鬼泣五中的招式众多，可以做出非常华丽的动作，单从连招来看，非常耐玩。但剧情有点短，两三句话就能说清楚，还没看过瘾，主线已经结束了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鬼泣五一周目达成&lt;/p&gt;</summary>
    
    
    
    <category term="娱乐" scheme="https://walu.space/categories/%E5%A8%B1%E4%B9%90/"/>
    
    
    <category term="游戏" scheme="https://walu.space/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="娱乐" scheme="https://walu.space/tags/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树中第K小元素</title>
    <link href="https://walu.space/2023/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/"/>
    <id>https://walu.space/2023/07/04/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/</id>
    <published>2023-07-04T13:29:29.000Z</published>
    <updated>2023-07-05T15:00:31.925Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">使用中序遍历获取二叉搜索树中第K小元素</a></p><span id="more"></span>  <p><strong>中序遍历二叉搜索树，得到的序列一定是升序的</strong></p><ol><li>使用栈实现中序遍历<br>这是官方解法，思路比较简单，第K个从栈中出来的元素就是要找的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode *&gt; stack;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>递归实现<br>代码逻辑我还没有想的很清楚，感觉递归也是可以做的，使用传引用的方式，把最终结果（α）当作参数传入函数。<br>使用return值记录递归次数，如果恰好是我们要找的那一次，则修改α的值，并且return -1，告诉上一层，已经找到这个数了，可以直接return。</p></li><li><p>争取明天把递归实现完成，今晚看TICU去了</p></li><li><p>递归解法(2中的思路)</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">solute</span>(root, k, count, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solute</span><span class="params">(TreeNode* root, <span class="type">int</span> k, <span class="type">int</span> &amp;count, <span class="type">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">solute</span>(root-&gt;left, k, count, res);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            count = <span class="number">-1</span>;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;res: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solute</span>(root-&gt;right, k, count, res);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            count = <span class="number">-1</span>;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/&quot;&gt;使用中序遍历获取二叉搜索树中第K小元素&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="刷题" scheme="https://walu.space/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Notion的缺陷</title>
    <link href="https://walu.space/2023/06/28/Notion%E7%9A%84%E7%BC%BA%E9%99%B7/"/>
    <id>https://walu.space/2023/06/28/Notion%E7%9A%84%E7%BC%BA%E9%99%B7/</id>
    <published>2023-06-28T09:05:14.000Z</published>
    <updated>2023-06-28T09:36:59.773Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午折腾了好几个小时的Notion ToDo List，发现很多我想要的功能都没有（；´д｀）ゞ</p><span id="more"></span><h3 id="1-模板自动填充时间"><a class="markdownIt-Anchor" href="#1-模板自动填充时间"></a> 1. 模板自动填充时间</h3><p>Notion的模板虽然可以设置自动重复，但是没法做到自动填充当前时间。背单词、刷题等任务，是我每天都会做的，所以我会让Notion模板每天都创建相同的任务，但扯淡的是，他不支持自动更新时间，你在模板上写的是哪天，重复创建每日任务的时候，时间写的还是那天，需要自己把时间改成今天</p><h3 id="2-table-view"><a class="markdownIt-Anchor" href="#2-table-view"></a> 2. Table View</h3><p>一个页面不能放两个Table View。全部的任务都放在数据库中，通过创建Table View并且设置Filter可以筛选出自己想要的内容，但Notion不支持一个页面中有多个Table View，所以，要想在一个页面同时看到两种相互冲突的任务，只能再加一个变量并且使用group进行分类</p><h3 id="3-最后编辑时间"><a class="markdownIt-Anchor" href="#3-最后编辑时间"></a> 3. 最后编辑时间</h3><p>Notion不支持获取某一列的最后编辑时间</p><h3 id="4-分组下拉填充"><a class="markdownIt-Anchor" href="#4-分组下拉填充"></a> 4. 分组&amp;下拉填充</h3><p>当使用group进行分组后，下拉填充功能又不好用了🤬</p><h3 id="5-未来优化"><a class="markdownIt-Anchor" href="#5-未来优化"></a> 5. 未来优化</h3><p>希望Notion将来可以内置Python解释器，或者微软直接Copy一个Notion(<a href="https://www.microsoft.com/en-us/microsoft-loop">微软已经在这么做了</a>)，让他的DataBase、Formula更加强大</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天下午折腾了好几个小时的Notion ToDo List，发现很多我想要的功能都没有（；´д｀）ゞ&lt;/p&gt;</summary>
    
    
    
    <category term="软件" scheme="https://walu.space/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="软件" scheme="https://walu.space/tags/%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="Notion" scheme="https://walu.space/tags/Notion/"/>
    
  </entry>
  
  <entry>
    <title>再也不碰炉石传说了</title>
    <link href="https://walu.space/2023/06/24/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%A2%B0%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E4%BA%86/"/>
    <id>https://walu.space/2023/06/24/%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%A2%B0%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E4%BA%86/</id>
    <published>2023-06-24T06:14:41.000Z</published>
    <updated>2023-06-24T07:00:47.261Z</updated>
    
    <content type="html"><![CDATA[<p>中午玩炉石标准模式破防了，一局都没赢┗|｀O′|┛</p><span id="more"></span><p>工作的时候，组了套40血DK<br>靠这套卡组上了白金，但死活打不到钻石<br>今天中午又想玩一下，打了四把，其中两个牧师，一个盗贼，一个法师。</p><h3 id="牧师"><a class="markdownIt-Anchor" href="#牧师"></a> 牧师</h3><ol><li>控制牧<br>偷牌好恶心，直接偷到了我的翻倍和帕奇维克，并且用偷到的帕奇维克又撕了我的希尔瓦娜斯。想着往后再坚持一下，等翻倍到了我还有一战之力，结果翻倍来的时候，我就剩14张牌了，血量也不高了，他直接拍出一个血誓，而我没抽到解牌，自己退了。</li><li>暗牧<br>暗牧前期天胡开局，而我前期没有啥解牌手段，5费用邪爆解了个场面，结果6费他直接复活了上个回合被我解掉的随从。想着下一轮有可能神抽，上了个嘲讽怪苟活一轮，结果被他用法术解掉了，直接被踢死。</li></ol><h3 id="盗贼"><a class="markdownIt-Anchor" href="#盗贼"></a> 盗贼</h3><ol><li>剑鱼贼<br>使用一堆BUFF，剑鱼刀加到了16点攻击力，4耐久，并且一堆单解，没有抗住，被砍死了。</li></ol><h3 id="法师"><a class="markdownIt-Anchor" href="#法师"></a> 法师</h3><ol><li>奥秘法<br>两个法反，两个生反，我的牌又都比较高费，前期血线被压得很低，后面直接两个4费打6的法术把我带走。</li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>40血DK就是沙包，对阵快攻，前期没啥自保能力，可能解牌还没抽到，就已经被踢死了。<br>打慢速卡组，一局一二十分钟，拼谁的资源多。牧师有女武神，相当于无限法术；法师有巅峰，也相当于无限法术；大哥术可以搞个无限瑞文；奥秘贼奥秘不停，最后再来个苔丝。打上面的慢速，感觉血DK十分乏力，除非7费准时翻倍，并且8非再用蛇发女妖把翻倍拿回来，二次翻倍，否则打慢速也感觉很难打。</li><li>现在非常讨厌炉石。这一局能不能赢，运气占比很大；卡组之间有明显的强弱之分，且存在克制关系（设计师就不能把所有的卡组都设计成55开的局面吗！！！单从数学上来讲，有可能把所有的卡组都设计成55开并且还各具特色吗？）</li><li>这种输赢靠运气影响比较大的游戏，仔细一想，和赌博比较类似。赌博真的有人能够算出来自己赢的概率吗？真的有人能够根据微表情，推测出对方的点数吗？同理，炉石这种游戏，可以从一开始就把自己取胜的概率算出来吗？</li><li>以后想玩游戏，我还是老老实实打开我的steam吧，《鬼泣5》买回来后还没玩过。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;中午玩炉石标准模式破防了，一局都没赢┗|｀O′|┛&lt;/p&gt;</summary>
    
    
    
    <category term="胡言乱语" scheme="https://walu.space/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="游戏" scheme="https://walu.space/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>对称二叉树</title>
    <link href="https://walu.space/2023/06/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://walu.space/2023/06/23/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-06-23T15:12:44.000Z</published>
    <updated>2023-06-23T15:39:59.992Z</updated>
    
    <content type="html"><![CDATA[<p>使用迭代判断二叉树是否对称</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; LeftTree;</span><br><span class="line">            stack&lt;TreeNode*&gt; RightTree;</span><br><span class="line">            TreeNode* left = root-&gt;left;</span><br><span class="line">            TreeNode* right = root-&gt;right;</span><br><span class="line">            LeftTree.<span class="built_in">push</span>(left);</span><br><span class="line">            RightTree.<span class="built_in">push</span>(right);</span><br><span class="line">            <span class="keyword">while</span>(!LeftTree.<span class="built_in">empty</span>() &amp;&amp; !RightTree.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* tmp1 = LeftTree.<span class="built_in">top</span>();</span><br><span class="line">                TreeNode* tmp2 = RightTree.<span class="built_in">top</span>();</span><br><span class="line">                LeftTree.<span class="built_in">pop</span>();</span><br><span class="line">                RightTree.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp1 == <span class="literal">NULL</span> &amp;&amp; tmp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp1 == <span class="literal">NULL</span> || tmp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp1-&gt;val == tmp2-&gt;val)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(tmp1-&gt;left != <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        LeftTree.<span class="built_in">push</span>(tmp1-&gt;left);</span><br><span class="line">                        RightTree.<span class="built_in">push</span>(tmp2-&gt;right);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;left == <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tmp1-&gt;right != <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        LeftTree.<span class="built_in">push</span>(tmp1-&gt;right);</span><br><span class="line">                        RightTree.<span class="built_in">push</span>(tmp2-&gt;left);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;right == <span class="literal">NULL</span> &amp;&amp; tmp2-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用迭代判断二叉树是否对称&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>TraverseBinaryTree</title>
    <link href="https://walu.space/2023/06/21/TraverseBinaryTree/"/>
    <id>https://walu.space/2023/06/21/TraverseBinaryTree/</id>
    <published>2023-06-21T14:54:46.000Z</published>
    <updated>2023-06-24T07:06:01.634Z</updated>
    
    <content type="html"><![CDATA[<p>使用C++实现二叉树的前中后序遍历&amp;层序遍历</p><span id="more"></span><blockquote><p>对于二叉树的前中后序遍历，在实际开发中，真的会有人用栈来实现吗？</p></blockquote><h3 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h3><ol><li>使用递归实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">preOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用栈实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* tmp = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3><ol><li>使用递归实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用栈实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    stack.<span class="built_in">push</span>(root);</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后续遍历"><a class="markdownIt-Anchor" href="#后续遍历"></a> 后续遍历</h3><ol><li>使用递归实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">postOrder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用栈实现<br>我傻傻的想要只用一个栈来实现后序遍历，看过题解之后，大家都是用两个栈来实现的。不过在思考过程中，想出了“中右左”遍历，再对遍历的结果前后翻转的解法。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* tmp = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                stack.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a class="markdownIt-Anchor" href="#层序遍历"></a> 层序遍历</h3><blockquote><p>每一层单独使用一个vector存储</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; gquiz;</span><br><span class="line">        gquiz.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!gquiz.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            length = gquiz.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">                TreeNode* tmp = gquiz.<span class="built_in">front</span>();</span><br><span class="line">                res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                gquiz.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    gquiz.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    gquiz.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用C++实现二叉树的前中后序遍历&amp;amp;层序遍历&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="https://walu.space/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="https://walu.space/2023/06/18/KMP/"/>
    <id>https://walu.space/2023/06/18/KMP/</id>
    <published>2023-06-18T12:58:57.000Z</published>
    <updated>2023-06-18T15:15:43.122Z</updated>
    
    <content type="html"><![CDATA[<p>重学<a href="https://www.youtube.com/watch?v=3IFxpozBs2I&amp;t=826s">KMP算法</a>，列出学习过程中我比较困惑的地方，给出前缀表的python实现</p><span id="more"></span><h3 id="较难理解的部分"><a class="markdownIt-Anchor" href="#较难理解的部分"></a> 较难理解的部分</h3><blockquote><p>使用python实现前缀表的计算，加深对2的理解</p></blockquote><ol><li>为什么要计算最长公共前后缀</li><li>增加字符，最长公共前后缀无法变长时怎么处理</li></ol><h3 id="前缀表代码实现"><a class="markdownIt-Anchor" href="#前缀表代码实现"></a> 前缀表代码实现</h3><blockquote><p>感觉实现方式有点像双指针+递归</p></blockquote><ol><li>python</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_table</span>(<span class="params">pattern</span>):</span><br><span class="line">    <span class="comment"># the lingest common prefix and suffix</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="comment"># prefix table &amp; init</span></span><br><span class="line">    prefix = [<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#index of the prefix table  </span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">len</span>(pattern)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;length &#123;:d&#125;, index: &#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(length, i))</span><br><span class="line">        <span class="keyword">if</span>(pattern[i] == pattern[length]):</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            prefix.append(length)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果不能和上一个最长公共前后缀组成更长的公共前后缀，使最长公共前后缀减一，</span></span><br><span class="line">        <span class="comment"># 考虑能不能和减一之后的公共前后缀组成一个更长的公共前后缀</span></span><br><span class="line">        <span class="comment"># 总结：既然和A组合之后没法生成更长的公共前后缀，那我就和试着和A的子串组合。</span></span><br><span class="line">            <span class="keyword">if</span>(length&lt;=<span class="number">0</span>):</span><br><span class="line">                prefix.append(<span class="number">0</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 关键一步，找到最长公共前后缀的最长公共前后缀</span></span><br><span class="line">                length = prefix[length-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pattern = <span class="string">&quot;ABABCABAA&quot;</span></span><br><span class="line">    prefix = prefix_table(pattern)</span><br><span class="line">    <span class="built_in">print</span>(prefix)</span><br></pre></td></tr></table></figure><ol start="2"><li>C语言（抄的黄浩杰大佬的）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prefix_table</span><span class="params">(<span class="type">char</span> pattern[], <span class="type">int</span> prefix[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern[i] == pattern[len]) &#123;</span><br><span class="line">      len++;</span><br><span class="line">      prefix[i] = len;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        len = prefix[len - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prefix[i] = len;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;重学&lt;a href=&quot;https://www.youtube.com/watch?v=3IFxpozBs2I&amp;amp;t=826s&quot;&gt;KMP算法&lt;/a&gt;，列出学习过程中我比较困惑的地方，给出前缀表的python实现&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://walu.space/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://walu.space/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>测试代码</title>
    <link href="https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <id>https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</id>
    <published>2023-06-11T03:09:31.000Z</published>
    <updated>2023-06-18T13:00:29.511Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
  <entry>
    <title>测试公式</title>
    <link href="https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E5%85%AC%E5%BC%8F/"/>
    <id>https://walu.space/2023/06/11/%E6%B5%8B%E8%AF%95%E5%85%AC%E5%BC%8F/</id>
    <published>2023-06-11T01:37:45.000Z</published>
    <updated>2023-06-18T14:21:16.460Z</updated>
    
    <content type="html"><![CDATA[<!-- ![mafumafu](../image/1500x500.jpg "") --><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mn>1</mn><mn>22</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- ![mafumafu](../image/1500x500.jpg &quot;&quot;) --&gt;
&lt;p class=&quot;katex-block&quot;&gt;&lt;span class=&quot;katex-display&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mat</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
  <entry>
    <title>测试图片</title>
    <link href="https://walu.space/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    <id>https://walu.space/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/</id>
    <published>2023-06-10T15:37:45.000Z</published>
    <updated>2023-06-18T14:21:22.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/1500x500.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/06/10/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/1500x500.jpg&quot; alt&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="TEST" scheme="https://walu.space/categories/TEST/"/>
    
    
    <category term="TEST" scheme="https://walu.space/tags/TEST/"/>
    
  </entry>
  
</feed>
